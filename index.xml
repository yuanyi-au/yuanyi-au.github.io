<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>方圆之所</title>
    <link>https://yuanyi-au.github.io/</link>
    <description>Recent content on 方圆之所</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>2021 Yuanyi. All rights reserved.</copyright>
    <lastBuildDate>Wed, 03 Nov 2021 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://yuanyi-au.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>Hugo 详细笔记（建站教程、工作原理）</title>
        <link>https://yuanyi-au.github.io/posts/hugo/</link>
        <pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yuanyi-au.github.io/posts/hugo/</guid>
        <description>方圆之所 https://yuanyi-au.github.io/posts/hugo/ -&lt;h1 id=&#34;基本概念&#34;&gt;基本概念&lt;/h1&gt;
&lt;h2 id=&#34;什么是-hugo&#34;&gt;什么是 Hugo&lt;/h2&gt;
&lt;p&gt;Hugo 是一个用 Go 编写的快速静态网站生成器，具有极快的构建速度（每个页面小于1毫秒），拥有大量现成主题，在开发过程中通过 liveload 即时渲染更改，可以托管在任何平台，是一个理想的建站工具。&lt;/p&gt;
&lt;h2 id=&#34;静态网站生成器&#34;&gt;静态网站生成器&lt;/h2&gt;
&lt;p&gt;网站生成器的目的是将内容转换为 HTML 文件，大多数网站生成器是动态的，这意味着每次用户请求页面时 HTTP 服务器都会运行生成器以创建新的 HTML 文件。动态站点生成器会将 HTML 文件缓存下来，以提高页面的加载速度。而 Hugo 更进一步，将 HTML 文件直接在计算机上渲染。在将文件复制到托管 HTTP 服务器的计算机之前可以在本地查看这些文件。因为 HTML 文件不是动态生成的，所以 Hugo 是一个静态网站生成器。&lt;/p&gt;
&lt;h1 id=&#34;快速建站&#34;&gt;快速建站&lt;/h1&gt;
&lt;h2 id=&#34;快速开始&#34;&gt;快速开始&lt;/h2&gt;
&lt;h3 id=&#34;在-windows-上安装&#34;&gt;在 Windows 上安装&lt;/h3&gt;
&lt;p&gt;最简单的方法是直接下载 &lt;a href=&#34;https://github.com/gohugoio/hugo/releases&#34;&gt;最新版本的 hugo&lt;/a&gt; 安装&lt;/p&gt;
&lt;p&gt;&lt;em&gt;请安装 extended 版本，可以对 scss 文件进行编译，否则在之后使用模板时会出现问题&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意：要把 hugo 的路径添加到环境变量 Path 中！&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我自己在下载安装扩展版本的时候有点问题，最后重新用 &lt;a href=&#34;https://gohugo.io/getting-started/installing/#chocolatey-windows&#34;&gt;Chocolatey&lt;/a&gt; 安装成功，非常方便。其它系统的安装过程可以看 &lt;a href=&#34;https://gohugo.io/getting-started/installing/&#34;&gt;官网文档&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;新建网站&#34;&gt;新建网站&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;hugo version&lt;/code&gt; 检查安装是否成功&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hugo new site [sitename]&lt;/code&gt; 创建一个新的网站&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hugo server&lt;/code&gt; 开启 Hugo 服务器，可以在本地预览调试网站&lt;/p&gt;
&lt;h3 id=&#34;结构目录&#34;&gt;结构目录&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;.
├── archetypes 
├── config.toml
├── content
├── data
├── layouts
├── static
└── themes
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;archetypes 文件夹：存放 front matter（前置数据）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;content 文件夹：存放网页的主要内容 Markdown 文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;layouts 文件夹：存放 HTML 模板&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;themes 文件夹：存放现有的主题模板&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;config.toml 文件：全局配置文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;data 文件夹：存放数据文件，通常是 json/yaml/toml 文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;static 文件夹：存放静态文件，会被直接复制到 public 目录下&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;使用现有-hugo-主题&#34;&gt;使用现有 Hugo 主题&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;a href=&#34;https://themes.gohugo.io/&#34;&gt;Hugo 官网&lt;/a&gt; 或者 GitHub 上寻找合适的 Hugo 主题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进入 &lt;code&gt;themes&lt;/code&gt; 文件夹，&lt;code&gt;git clone&lt;/code&gt; 想要使用的主题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在配置文件中添加主题：&lt;code&gt;theme = &amp;quot;themename&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;站点部署&#34;&gt;站点部署&lt;/h3&gt;
&lt;p&gt;利用 Hugo 搭建的网站可以托管在任何地方，包括 Netlify、Heroku、GoDaddy、DreamHost、GitHub Pages、GitLab Pages、Surge、Aerobatic、Firebase、Google Cloud Storage、Amazon S3、Rackspace、Azure 和 CloudFront，并且可以很好地与 CDN 配合使用。无需依赖数据库或 runtime 即可运行。&lt;/p&gt;
&lt;h4 id=&#34;部署到-github-pages&#34;&gt;部署到 GitHub Pages&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;进入本地代码根目录，执行 &lt;code&gt;hugo&lt;/code&gt; 生成 &lt;code&gt;public&lt;/code&gt; 文件夹&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 GitHub 上创建一个新仓库，起名为 &lt;code&gt;github_id.github.io&lt;/code&gt; （例如 yuanyi-au.github.io ），将本地 &lt;code&gt;public&lt;/code&gt; 文件夹与此仓库关联，push 到远程仓库中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 GitHub 仓库设置中找到 GitHub Pages，可以看到网站地址 &lt;code&gt;github_id.github.io&lt;/code&gt;，就能进行访问了&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意：&lt;code&gt;public&lt;/code&gt; 文件夹的内容需要每次在项目根目录执行 &lt;code&gt;hugo&lt;/code&gt; 命令后才会更新，然后 push 到远程仓库中由 GitHub Pages 部署&lt;/p&gt;
&lt;h4 id=&#34;部署到-netlify&#34;&gt;部署到 Netlify&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装 &lt;a href=&#34;https://github.com/apps/netlify&#34;&gt; Netlify &lt;/a&gt;，授权 GitHub 账号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;New site from Git&lt;/p&gt;
&lt;p&gt;选择平台 - 选择仓库 - 选择分支 - 基本设置（&lt;a href=&#34;https://docs.netlify.com/configure-builds/common-configurations/&#34;&gt;Build command &amp;amp; Publish directory&lt;/a&gt;） - deploy site，部署成功就可以访问了&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;工作原理&#34;&gt;工作原理&lt;/h1&gt;
&lt;p&gt;如果需要对现有主题进行布局方面的修改，甚至自己创建一个新的主题，就不得不对 Hugo 的工作原理有一定了解。同一些其他的静态网站生成器（如 Jekyll ）一样，Hugo 将网站的内容和逻辑分离开来，方便更好地管理网站内容。在这里简单介绍一下 Hugo 中的内容、模板、页面三个部分以及它们之间的联系。&lt;/p&gt;
&lt;h2 id=&#34;内容&#34;&gt;内容&lt;/h2&gt;
&lt;p&gt;Hugo 会将 content 文件夹里的 Markdown 文档转换为页面，content 文件夹的目录结构对应着网站目录结构（会生成 section tree）。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;└── content
    ├── _index.md          //  https://example.com/
    ├── about.md           //  https://example.com/about/
    ├── posts               
    |   ├── _index.md      //  https://example.com/posts/         
    |   ├── firstpost.md   //  https://example.com/posts/firstpost/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果通过命令行 &lt;code&gt;hugo new xxx&lt;/code&gt; 创建内容页面，Hugo 会按照 archetypes 中的设置自动创建 title、date 等 front matter。如果是在文件目录下直接创建的内容页面则需要自己在文档开头手动添加 front matter，用 “+++” 或者“&amp;mdash;”分隔。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;---
title = &amp;quot;Hugo Website&amp;quot;
---
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;模板&#34;&gt;模板&lt;/h2&gt;
&lt;p&gt;Hugo 将模板存放在两个地方：themes 和 layouts 文件夹。layouts 中的模板优先级高于 themes，如果需要修改现有模板，在 layouts 文件夹中依照 themes 文件夹的目录层级结构编写新的模板即可覆盖。&lt;/p&gt;
&lt;h3 id=&#34;模板语法&#34;&gt;模板语法&lt;/h3&gt;
&lt;p&gt;首先推荐一篇特别简洁实用的文章： &lt;a href=&#34;https://www.regisphilibert.com/blog/2018/02/hugo-the-scope-the-context-and-the-dot/&#34;&gt;Hugo, the scope, the context and the dot&lt;/a&gt;，看完这篇后基本就可以从零开始写出一个简单的模板。&lt;/p&gt;
&lt;p&gt;Hugo 使用 Go 语言的 &lt;a href=&#34;https://pkg.go.dev/html/template&#34;&gt;html/template 库&lt;/a&gt; 作为模版引擎， 模板的标签为 &lt;code&gt;{{}}&lt;/code&gt; ,  &lt;code&gt;{{}}&lt;/code&gt; 中包含的内容叫“动作”(action)，动作分为两种类型：数据求值与控制结构。&lt;/p&gt;
&lt;p&gt;模板是通过将它们应用于数据结构来执行的。模板中的注释引用数据结构的元素来控制执行并导出要显示的值。模板的执行会遍历结构并设置光标，
由句点 “.” 表示，并称为“点”，随着执行的进行到结构中当前位置的值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基础语法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//点
{{.}}
代表传递给模板的数据，表示当前模板的上下文，可以是 Go 语言中的任何类型，比如字符串、数组、结构体等

//注释
{{/* comment */}}

//空格
{{- pipeline -}} // 清除 pipeline 前后的空格
{{- pipeline }} // 清除 pipeline 前面的空格

//变量赋值
{{$变量名 := &amp;quot;值&amp;quot;}}

//条件判断
{{if pipeline}} T1 {{else}} T0 {{end}}
如果不为空则输出T1，否则输出T0
{{if pipeline}} T1 {{else if pipeline}} T0 {{end}}

//循环语句
{{range pipeline}} T1 {{end}}
pipeline 的值必须是数组，切片，map，channel，设置 点. 为数组，切片遍历 map 的值，输出T1

//with 重设点.的值
{{with pipeline}} T1 {{else}} T0 {{end}}
如果 pipeline 的值为空， 点. 的值不受影响,输出T1，否则 点. 的值设置成 pipeline 的值，输出T0
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义子模板：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//define
{{define &amp;quot;name&amp;quot;}} T1 {{end}}
定义一个特定名称的模板

//template
{{template &amp;quot;name&amp;quot;}}
引入指定名称的模板，不传入任何数据.

{{template &amp;quot;name&amp;quot; pipeline}}
引入指定名称的模板，设置模板上下文 点. 的值为 pipeline 的值

//block
{{block &amp;quot;name&amp;quot; pipeline}} T1 {{end}}
定义特定名称的模板，并在当前位置引入该名称的模板，模板的上下文 点. 的值为 pipline 的值，如果该名称的模板未实现(不存在)，则输出T1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;模板类型&#34;&gt;模板类型&lt;/h3&gt;
&lt;h4 id=&#34;基本模板类型&#34;&gt;基本模板类型&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;single template：用于渲染单个页面（Leaf Bundle）的内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;list template：用于渲染具有子页面的页面（Branch Bundle）的内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;partial template：能够被其他模版引用，可以理解为模版级别的组件，例如   header、footer 等&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;partial-与-shortcode-的区别&#34;&gt;Partial 与 Shortcode 的区别&lt;/h4&gt;
&lt;p&gt;一般来说，需要经常复用的局部组件使用 Partial，因为 Partial 可以被任何模板引用，而 Shortcode 只能被 content 引用。&lt;/p&gt;
&lt;p&gt;引用方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Partial： &lt;code&gt;{{ partial &amp;quot;&amp;lt;PATH&amp;gt;/&amp;lt;PARTIAL&amp;gt;.html&amp;quot; . }}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Shortcode： &lt;code&gt;{{% shortcodename parameters %}}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以及两者的参数传入也略有不同，可以参见 &lt;a href=&#34;https://gohugo.io/templates/partials/#variable-scoping&#34;&gt;官方文档&lt;/a&gt; 中的相关内容。&lt;/p&gt;
&lt;h2 id=&#34;页面&#34;&gt;页面&lt;/h2&gt;
&lt;p&gt;内容 + 模板 = 页面&lt;/p&gt;
&lt;h3 id=&#34;页面捆绑page-bundles&#34;&gt;页面捆绑（Page Bundles）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Leaf Bundle：无子页面&lt;/li&gt;
&lt;li&gt;Branch Bundle：有子页面&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;页面和模板的对应关系&#34;&gt;页面和模板的对应关系&lt;/h3&gt;
&lt;p&gt;页面和模板的对应关系是根据页面的一系列属性决定的，包括: Kind、Output Format、Language、Layout、Type、Section，其中kind、layout、type、section 用的比较多。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;kind：用于确定页面的类型，单页面使用 single.html 为默认模板页，列表页使用 list.html 为默认模板页，值不能被修改&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;section：用于确定 section tree 下面的文章的模板，section tree 的结构是由 content 目录结构生成的，不能被修改，content 目录下的一级目录自动成为 root section，二级及以下的目录需要在目录下添加 _index.md 文件才能成为 section tree 的一部分，如果页面不在 section tree 下 section 的值为空&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;type：可以在 front matter 中设置，用户指定模板的类型. 默认情况下 type 的值等于 section 或 page（section为空的时候）的值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;layout：可以在 front matter 中设置，指定具体的模板名称&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Hugo 按照从上到下的顺序依次查找模板并应用（特定页面模板 - 某一类页面的模板 - 全站模板）&lt;/p&gt;
&lt;h1 id=&#34;问题解决&#34;&gt;问题解决&lt;/h1&gt;
&lt;h2 id=&#34;markdown-代码块中的-shortcodes-被解析&#34;&gt;Markdown 代码块中的 Shortcodes 被解析&lt;/h2&gt;
&lt;p&gt;这个问题很有趣，是在写这篇博客过程中遇到的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;问题描述：&lt;/p&gt;
&lt;p&gt;当我在写模板引用方式的时候，我是这样写的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../images/hugo-called.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;执行 &lt;code&gt;hugo&lt;/code&gt; 或者 &lt;code&gt;hugo server&lt;/code&gt; 时报错：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;failed to extract shortcode: template for shortcode &amp;quot;shortcodename&amp;quot; not found&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;问题解决：&lt;/p&gt;
&lt;p&gt;在 Hugo 社区里得到的答复：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../images/hugo-shortcodes.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;public-文件夹渲染出错&#34;&gt;Public 文件夹渲染出错&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;问题描述：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hugo server&lt;/code&gt; 在本地运行时没有问题，但部署上线后打开网页发现渲染缺失 css 和 js 文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;问题解决：&lt;/p&gt;
&lt;p&gt;问题出在 Hugo 本身处理 URL 的方式上，可以参见 &lt;a href=&#34;https://github.com/matcornic/hugo-theme-learn/issues/125&#34;&gt;issue&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;baseURL = &amp;quot;//example.org&amp;quot;
relativeURLs = true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的方法没有解决我的问题，后来试了两种方法可行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;`# baseURL = &amp;quot;example.org&amp;quot;`

`baseURL = &amp;quot;\&amp;quot;`
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;找不到新增的页面&#34;&gt;找不到新增的页面&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;问题描述：&lt;/p&gt;
&lt;p&gt;增加的内容在 index 页面有链接，但点开却找不到页面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;问题解决：&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;hugo -t theme_name&lt;/code&gt; 代替 &lt;code&gt;hugo&lt;/code&gt; 命令进行编译&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;图片加载问题&#34;&gt;图片加载问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;问题描述：&lt;/p&gt;
&lt;p&gt;Markdown 文档里的本地图片无法显示&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;目录结构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;├── content
  └── posts 
    ├── cat.md
    ├── dog.md
    └── images
      ├── cat.png
      └── dog.png
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;图片链接：
&lt;code&gt;![dog](../images/dog.png)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我用这个方法能成功加载出图片，但好像有些人不行，可以看看 Hugo 社区里的讨论 &lt;a href=&#34;https://discourse.gohugo.io/t/replace-image-reference-link/35314&#34;&gt;Replace Image Reference link&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;最后修改时间&#34;&gt;最后修改时间&lt;/h2&gt;
&lt;p&gt;可以通过两种方式记录 Last Modified 时间&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在文档开头加上时间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;date: 1990-01-01T00:00:00+00:00
lastmod: 1995-04-04T00:00:00+00:00
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 config.toml 内设置使用 Git 记录&lt;/p&gt;
&lt;p&gt;&lt;code&gt;enableGitInfo = true&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://gohugo.io/&#34;&gt;HUGO&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/gohugoio/hugoDocs/files/1242701/static-site-generators.pdf&#34;&gt;“Static Site Generators”, O’Reilly&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://discourse.gohugo.io/t/how-does-hugo-work/11037/8&#34;&gt;How does Hugo work?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://discourse.gohugo.io/t/could-shortcodes-and-partials-be-unified/1348&#34;&gt;Could shortcodes and partials be unified?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.regisphilibert.com/blog/2018/02/hugo-the-scope-the-context-and-the-dot/&#34;&gt;Hugo, the scope, the context and the dot&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jakewiesler.com/blog/hugo-directory-structure&#34;&gt;Hugo&amp;rsquo;s Directory Structure Explained&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://hugo.aiaide.com/&#34;&gt;Reset hugo中文帮助文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000016078760&#34;&gt;Hugo-框架学习&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=qtIqKaDlqXo&amp;amp;list=PLLAZ4kZ9dFpOnyRlyS-liKL5ReHDcj4G3&#34;&gt; Hugo - Static Site Generator | Tutorial &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=LIFvgrRxdt4&amp;amp;t=247s&#34;&gt; Creating a Blog with Hugo and Github in 10 minutes &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=wcMqrb3v2SM&amp;amp;list=LLm-KB0VAVChbSZPeDA_WqSg&#34;&gt; Creating your own Hugo Theme! &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://retrolog.io/blog/creating-a-hugo-theme-from-scratch/&#34;&gt; Creating a Hugo Theme From Scratch &lt;/a&gt;&lt;/p&gt;
- https://yuanyi-au.github.io/posts/hugo/ - 2021 Yuanyi. All rights reserved.</description>
        </item>
    
    
    
        <item>
        <title>浏览器基本原理</title>
        <link>https://yuanyi-au.github.io/posts/browser/</link>
        <pubDate>Sat, 02 Oct 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yuanyi-au.github.io/posts/browser/</guid>
        <description>方圆之所 https://yuanyi-au.github.io/posts/browser/ -&lt;h1 id=&#34;浏览器简介&#34;&gt;浏览器简介&lt;/h1&gt;
&lt;p&gt;目前的主流浏览器有五个：IE、Firefox、Safari、Chrome 和 Opera&lt;/p&gt;
&lt;p&gt;浏览器的主要功能是向服务器发出请求，然后在浏览器窗口中呈现返回的资源&lt;/p&gt;
&lt;p&gt;浏览器的主要组件有：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/layers.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户界面&lt;/li&gt;
&lt;li&gt;浏览器引擎&lt;/li&gt;
&lt;li&gt;渲染引擎&lt;/li&gt;
&lt;li&gt;网络&lt;/li&gt;
&lt;li&gt;UI 后端&lt;/li&gt;
&lt;li&gt;JavaScript 解释器&lt;/li&gt;
&lt;li&gt;数据存储&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;进程与线程&#34;&gt;进程与线程&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;进程：资源（CPU、内存）分配的最小单位&lt;/li&gt;
&lt;li&gt;线程：是在进程内部的程序运行单位&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每打开一个新的标签页就新建了一个进程（如果后期标签页过多可能会合并进程）&lt;/p&gt;
&lt;h2 id=&#34;浏览器中的主要进程&#34;&gt;浏览器中的主要进程&lt;/h2&gt;
&lt;p&gt;浏览器进程、第三方插件进程、GPU 进程、渲染进程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多进程的优点：某一页面进程出问题不会影响其他页面，避免不同页面的权限问题，以及第三方插件的问题&lt;/li&gt;
&lt;li&gt;多进程的缺点：内存消耗大，不同进程中常常包含相同内容&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;死锁&#34;&gt;死锁&lt;/h2&gt;
&lt;p&gt;在多个进程执行过程中因资源争夺而造成的僵持状态，此时若没有干预这些线程就都将无法向前推进。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;产生死锁的必要条件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;互斥条件：进程要求对所分配的资源进行排它性控制&lt;/li&gt;
&lt;li&gt;请求和保持条件：当进程因请求资源而阻塞时，对已经获得的资源保持不放&lt;/li&gt;
&lt;li&gt;不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放&lt;/li&gt;
&lt;li&gt;环路等待条件：在发生死锁时，必然存在一个进程-资源的环形链&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决死锁的方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;预防死锁&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一次性分配所有资源，这样就不会再请求资源了&lt;/li&gt;
&lt;li&gt;如果某进程获得了部分资源，但得不到剩下的资源，则释放已有资源（超时放弃）&lt;/li&gt;
&lt;li&gt;给资源编号，有序分配&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免死锁&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在进行资源分配前先计算安全性，若安全才进行分配，否则进程等待&lt;/li&gt;
&lt;li&gt;银行家算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解除死锁&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从其他进程中剥夺资源给死锁进程，以解除死锁状态&lt;/li&gt;
&lt;li&gt;直接撤销死锁进程，或撤销代价最小的进程直到资源足够接触死锁进程为止&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;渲染进程浏览器内核&#34;&gt;渲染进程（浏览器内核）&lt;/h1&gt;
&lt;p&gt;渲染进程也就是我们说的浏览器内核&lt;/p&gt;
&lt;h2 id=&#34;gui-渲染线程&#34;&gt;GUI 渲染线程&lt;/h2&gt;
&lt;p&gt;作用：负责渲染页面&lt;/p&gt;
&lt;h3 id=&#34;渲染流程&#34;&gt;渲染流程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;构建 DOM ：根据 HTML 渲染 DOM（同一个 HTML 文件得到的DOM 树并不总是一样，浏览器会按照自己的规范来构建）&lt;/li&gt;
&lt;li&gt;加载次级资源：请求下载图片，CSS，JS 等资源&lt;/li&gt;
&lt;li&gt;JS 的下载与执行：&amp;lt;script&amp;gt;&lt;/li&gt;
&lt;li&gt;样式计算：基于 CSS 选择器解析 CSS 计算每个节点的具体样式值&lt;/li&gt;
&lt;li&gt;获取布局：遍历 DOM 以及相关元素的计算样式，构建出布局树&lt;/li&gt;
&lt;li&gt;绘制各元素：遍历布局树，创建绘制记录&lt;/li&gt;
&lt;li&gt;合成帧：遍历布局树，创建层树，合成器将每一层栅格化然后合成帧（合成器是独立工作的，与主线程无关，非常流畅）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;js-引擎线程&#34;&gt;JS 引擎线程&lt;/h2&gt;
&lt;p&gt;作用：负责解析执行 JS 脚本&lt;/p&gt;
&lt;p&gt;JS 引擎线程是单线程，容易引发的阻塞问题， HTML5 提出了 Web Worker 解决此问题，允许主线程创建 Worker 线程，将一些任务分配给该线程在后台运行。JS 引擎线程与 Worker 线程之间通过 postMessage API 进行通信&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JS 引擎线程与 GUI 渲染线程互斥，无法同时进行，因为 JS 也可以操作 DOM，会影响渲染结果&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;事件触发线程&#34;&gt;事件触发线程&lt;/h2&gt;
&lt;p&gt;作用：控制事件循环&lt;/p&gt;
&lt;h3 id=&#34;事件循环&#34;&gt;事件循环&lt;/h3&gt;
&lt;p&gt;同步任务直接放入 JS 引擎线程中的执行栈中处理，异步任务放入事件触发线程中的事件队列中等待。&lt;/p&gt;
&lt;p&gt;当 JS 引擎线程上的执行栈为空时，JS 引擎线程会询问事件触发线程，如果事件队列中有异步任务，就会被添加到执行栈中开始执行。&lt;/p&gt;
&lt;h2 id=&#34;定时触发器线程&#34;&gt;定时触发器线程&lt;/h2&gt;
&lt;p&gt;作用：执行 setInterval 与 setTimesout，计时完毕后通知事件触发线程&lt;/p&gt;
&lt;h2 id=&#34;异步http请求线程&#34;&gt;异步http请求线程&lt;/h2&gt;
&lt;p&gt;作用：在 XMLHttpRequest 连接后通过浏览器新开一个线程请求。当检测到状态变更时，如果设置有回调函数，异步线程就会产生状态变更事件，将回调放入事件队列中，再由 JS 引擎执行。&lt;/p&gt;
&lt;h1 id=&#34;浏览器缓存&#34;&gt;浏览器缓存&lt;/h1&gt;
&lt;p&gt;浏览器会把通过 HTTP 获取的所有资源保存到本地&lt;/p&gt;
&lt;h2 id=&#34;缓存位置&#34;&gt;缓存位置&lt;/h2&gt;
&lt;p&gt;Service Worker：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;内存缓存 memory cache&lt;/th&gt;
&lt;th&gt;硬盘缓存 disk cache&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;读取速度快&lt;/td&gt;
&lt;td&gt;读取速度慢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;退出进程时数据会被清除&lt;/td&gt;
&lt;td&gt;退出进程时数据不会被清除&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;通常 memory cache 保存 JS、字体、图片等文件，disk cache 保存 CSS 文件&lt;/p&gt;
&lt;h2 id=&#34;访问缓存优先级&#34;&gt;访问缓存优先级&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在内存中查找&lt;/li&gt;
&lt;li&gt;在硬盘中查找&lt;/li&gt;
&lt;li&gt;进行网络请求&lt;/li&gt;
&lt;li&gt;把获取的资源缓存到本地&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;强制缓存-和-协商缓存&#34;&gt;强制缓存 和 协商缓存&lt;/h2&gt;
&lt;p&gt;浏览器在请求某一资源时，会先获取该资源缓存的 header 信息，判断是否命中强缓存，若命中则直接从缓存中获取资源信息，不会与服务器进行通信。若没有命中强缓存，浏览器会向服务器发送携带之前获取到的有关缓存的 header 信息，服务器对比相关 header 信息看是否命中协商缓存，若命中则服务器返回新的响应 header 信息更新缓存中对应的 header 信息，告知浏览器可以直接从缓存中获取资源信息，若没有命中协商缓存，则会直接返回最新的资源内容&lt;/p&gt;
&lt;h2 id=&#34;http-报文中的缓存相关字段&#34;&gt;HTTP 报文中的缓存相关字段&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Cache-Control&lt;/p&gt;
&lt;p&gt;http 1.1 出现的 header 字段，可以定义资源什么时候被缓存、如何被缓存以及缓存多长时间等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Last-Modify&lt;/p&gt;
&lt;p&gt;标识资源的最后修改时间，浏览器第一次请求一个资源的时候，服务器返回的 header 中会加上 Last-Modify。当浏览器再次请求该资源时，服务器会根据资源的最后修改时间判断是否命中缓存。如果命中缓存，则返回 304，并且不会返回资源内容，如果未命中，返回 200 和新的资源，并带上新的修改时间 Last-Modify。&lt;/p&gt;
&lt;p&gt;缺点：短时间内如果资源发生变化，Last-Modified 并不会变化，可以用 Etag 处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Etag&lt;/p&gt;
&lt;p&gt;服务器针对资源计算出一串校验码，通过 Etag 返回给客户端，客户端下次请求时带上该值，服务器对比校验，如果相同则返回 304，不返回资源，不一致则返回 412 和新的资源。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Layered_representation&#34;&gt;浏览器的工作原理：新式网络浏览器幕后揭秘&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6844903553795014663#heading-0&#34;&gt;从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/47407398&#34;&gt;图解浏览器的基本工作原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/e05307cf8f6a&#34;&gt;浏览器原理机制&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2018/07/web-worker.html&#34;&gt;Web Worker 使用教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/u012375924/article/details/82806617&#34;&gt;浅谈http中的Cache-Control&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000017962411&#34;&gt;实践这一次，彻底搞懂浏览器缓存机制&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/hd12370/article/details/82814348&#34;&gt;死锁面试题（什么是死锁，产生死锁的原因及必要条件）&lt;/a&gt;&lt;/p&gt;
- https://yuanyi-au.github.io/posts/browser/ - 2021 Yuanyi. All rights reserved.</description>
        </item>
    
    
    
        <item>
        <title>React.js 小书笔记</title>
        <link>https://yuanyi-au.github.io/posts/reactjsbook/</link>
        <pubDate>Thu, 23 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yuanyi-au.github.io/posts/reactjsbook/</guid>
        <description>方圆之所 https://yuanyi-au.github.io/posts/reactjsbook/ -&lt;p&gt;&lt;a href=&#34;https://www.bookstack.cn/read/react-naive-book/about.md&#34;&gt;React.js 小书在线阅读&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;reactjs&#34;&gt;React.js&lt;/h1&gt;
&lt;h2 id=&#34;基础知识&#34;&gt;基础知识&lt;/h2&gt;
&lt;p&gt;MVVM（Model-View-ViewModel）：是 MVC（Model View Controller） 的改进版，一种将图形用户界面开发与业务逻辑或后端逻辑的开发分离开来的软件架构模式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Model层：请求的原始数据&lt;/li&gt;
&lt;li&gt;View层：视图展示，由ViewController来控制&lt;/li&gt;
&lt;li&gt;ViewModel层：负责业务处理和数据转化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以参考 &lt;a href=&#34;https://www.w3cschool.cn/ios_functional_reactive_program/ios_functional_reactive_program-vjix288i.html&#34;&gt;什么是MVVM&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;React 只是一个库，而不是框架，它只提供 UI 也就是 View 层面的解决方案，需要结合其它的库（如 Redux、React-router ）来协助提供完整的解决方法。&lt;/p&gt;
&lt;h2 id=&#34;jsx&#34;&gt;JSX&lt;/h2&gt;
&lt;p&gt;一个 DOM 元素包含的信息其实只有三个：标签名，属性，子元素，这些信息既可以用 HTML 也可以用 JS 来描述，但 HTML 写起来比 JS 简便许多。 于是 React.js 把 JS 语法扩展了一下，支持直接在 JS 代码里面编写类似 HTML 标签结构的语法，也就是 JSX。JSX 在编译的时候会变成相应的 JavaScript 对象描述。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ReactDOM.render(
 &amp;lt;Header /&amp;gt;, 
  document.getElementById(&#39;root&#39;)
)
//会被编译成：
ReactDOM.render(
  React.createElement(Header, null), 
  document.getElementById(&#39;root&#39;)
)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从 JSX 到页面经历的过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://huzidaha.github.io/static/assets/img/posts/44B5EC06-EAEB-4BA2-B3DC-325703E4BA45.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;不直接从 JSX 直接渲染构造 DOM 结构的原因：&lt;/p&gt;
&lt;p&gt;元素不一定会被渲染到浏览器页面上，也可能渲染到 canvas 或者 RN 上&lt;/p&gt;
&lt;h2 id=&#34;render&#34;&gt;render&lt;/h2&gt;
&lt;p&gt;一个组件类必须要实现一个 render 方法，这个 render 方法必须要返回一个 JSX 元素。&lt;/p&gt;
&lt;p&gt;必须要用一个外层的 JSX 元素（比如&lt;!-- raw HTML omitted --&gt;）把所有内容包裹起来。返回并列多个 JSX 元素是不合法的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;render () {
  return (
    &amp;lt;div&amp;gt;
      &amp;lt;div&amp;gt;第一个&amp;lt;/div&amp;gt;
      &amp;lt;div&amp;gt;第二个&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为 class 是 JavaScript 的关键字，所以 React.js 定义了 className 给元素添加类名。&lt;/p&gt;
&lt;p&gt;因为 JSX 元素其实是 JS 对象，一次可以将 JSX 元素赋值给变量，或者作为函数参数、函数参数返回值。&lt;/p&gt;
&lt;h2 id=&#34;事件监听&#34;&gt;事件监听&lt;/h2&gt;
&lt;p&gt;在 React.js 不需要手动调用浏览器原生的 addEventListener 进行事件监听，React.js 帮我们封装好了一系列的 on 属性，当你需要为某个元素监听某个事件的时候，只需要简单地给它加上 on 就可以了。&lt;/p&gt;
&lt;p&gt;但是注意，这些 on 的事件监听只能用在普通的 HTML 的标签上，不能用在组件标签上。&lt;/p&gt;
&lt;h2 id=&#34;this&#34;&gt;this&lt;/h2&gt;
&lt;p&gt;如果想在事件函数当中使用当前的实例，你需要手动地将实例方法 bind 到 this 上再传入给 React.js，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Title extends Component {
  handleClickOnTitle (word, e) {
    console.log(this, word)
  }
  render () {
    return (
      &amp;lt;h1 onClick={this.handleClickOnTitle.bind(this, &#39;Hello&#39;)}&amp;gt;React 小书&amp;lt;/h1&amp;gt;
    )
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;state-与-setstate&#34;&gt;state 与 setState&lt;/h2&gt;
&lt;p&gt;state 用来存储可变化的状态&lt;/p&gt;
&lt;p&gt;当我们调用 setState 方法时，React.js 会更新组件的状态 state ，并且重新调用 render 方法渲染页面。&lt;/p&gt;
&lt;p&gt;调用 setState 的时候，React.js 并不会马上修改 state，而是把这个对象放到一个更新队列里面，稍后才会从队列当中把新的状态提取出来合并到 state 当中，然后再触发组件更新。&lt;/p&gt;
&lt;p&gt;如果需要在后续操作依赖前一个 setState 的结果，可以给 setState 传入一个函数作为参数，就能利用上一次 SetState 的结果了，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  handleClickOnLikeButton () {
    this.setState((prevState) =&amp;gt; {
      return { count: 0 }
    })
    this.setState((prevState) =&amp;gt; {
      return { count: prevState.count + 1 } // 上一个 setState 的返回是 count 为 0，当前返回 1
    })
    this.setState((prevState) =&amp;gt; {
      return { count: prevState.count + 2 } // 上一个 setState 的返回是 count 为 1，当前返回 3
    })
    // 最后的结果是 this.state.count 为 3
  }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;React.js 内部会把 JS 事件循环中的消息队列的同一个消息中的 setState 都进行合并以后再重新渲染组件，因此并不需要担心多次进行 setState 会带来性能问题。&lt;/p&gt;
&lt;h2 id=&#34;props&#34;&gt;props&lt;/h2&gt;
&lt;p&gt;每个组件都可以接受一个 props 参数，它是一个对象，包含了所有你对这个组件的配置。&lt;/p&gt;
&lt;p&gt;组件可以在内部通过 this.props 获取到配置参数，props 一旦传入，就不可以在组件内部修改，但可以通过父组件主动重新渲染的方式（比如调用 setState）来传入新的 props，从而达到更新的效果。&lt;/p&gt;
&lt;p&gt;state 是让组件控制自己的状态，props 是让外部对组件自己进行配置。因为状态会带来管理的复杂性，推荐多使用无状态组件。&lt;/p&gt;
&lt;h2 id=&#34;状态提升&#34;&gt;状态提升&lt;/h2&gt;
&lt;p&gt;将组件之间共享的状态交给组件最近的公共父节点保管，然后通过 props 把状态传递给子组件，这样就可以在组件之间共享数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://huzidaha.github.io/static/assets/img/posts/C547BD3E-F923-4B1D-96BC-A77966CDFBEF.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;但如果提升路径发生改变，需要修改的地方就很多，这个问题 React.js 还没有很好地解决，不过可以通过 Redux 来管理状态。&lt;/p&gt;
&lt;h2 id=&#34;生命周期&#34;&gt;生命周期&lt;/h2&gt;
&lt;h3 id=&#34;挂载阶段&#34;&gt;挂载阶段&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;-&amp;gt; constructor()
-&amp;gt; componentWillMount()
-&amp;gt; render()
// 然后构造 DOM 元素插入页面
-&amp;gt; componentDidMount()
// ...
// 即将从页面中删除
-&amp;gt; componentWillUnmount()
// 从页面中删除
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;constructor：组件自身状态初始化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;componentWillMount：组件启动动作（例如 Ajax 数据的拉取操作、定时器的启动等）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;componentDidMount：依赖 DOM 的启动（例如动画的启动）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;componentWillUnmount：在组件销毁时清除定时器和数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;更新阶段&#34;&gt;更新阶段&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;shouldComponentUpdate(nextProps, nextState)：可以通过这个方法控制组件是否重新渲染。可以用在性能优化上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;componentWillReceiveProps(nextProps)：组件从父组件接收到新的 props 之前调用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;componentWillUpdate()：组件开始重新渲染之前调用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;componentDidUpdate()：组件重新渲染并且把更改变更到真实的 DOM 以后调用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ref-属性&#34;&gt;ref 属性&lt;/h2&gt;
&lt;p&gt;用来获取已经挂载的元素的 DOM 节点然后调用 DOM API&lt;/p&gt;
&lt;p&gt;&lt;em&gt;原则：能不用 ref 就不用&lt;/em&gt; 特别是要避免用 ref 来做 React.js 本来就可以帮助你做到的页面自动更新的操作和事件监听。&lt;/p&gt;
&lt;h2 id=&#34;propschildren&#34;&gt;props.children&lt;/h2&gt;
&lt;p&gt;所有嵌套在组件中的 JSX 结构都可以在组件内部通过 props.children 获取到，可以在各个地方高度复用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Layout extends Component {
  render () {
    return (
      &amp;lt;div className=&#39;two-cols-layout&#39;&amp;gt;
        &amp;lt;div className=&#39;sidebar&#39;&amp;gt;
          {this.props.children[0]}
        &amp;lt;/div&amp;gt;
        &amp;lt;div className=&#39;main&#39;&amp;gt;
          {this.props.children[1]}
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    )
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;dangerouslysethtml&#34;&gt;dangerouslySetHTML&lt;/h2&gt;
&lt;p&gt;因为设置 innerHTML 可能会导致跨站脚本攻击（XSS），在 React.js 当中所有的表达式插入的内容都会被自动转义，动态 HTML 结构无法正常渲染&lt;/p&gt;
&lt;p&gt;给 dangerouslySetInnerHTML 传入一个对象，这个对象的 __html 属性值就相当于元素的 innerHTML，这样就可以动态渲染元素的 innerHTML 结构&lt;/p&gt;
&lt;h2 id=&#34;style-属性&#34;&gt;style 属性&lt;/h2&gt;
&lt;p&gt;在 React.js 中你需要把 CSS 属性变成一个对象再传给元素：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;h1 style={{fontSize: &#39;12px&#39;, color: &#39;red&#39;}}&amp;gt;React.js 小书&amp;lt;/h1&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;原来 CSS 属性中带 - 的元素都必须要去掉 - 换成驼峰命名，如 font-size 换成 fontSize，text-align 换成 textAlign&lt;/p&gt;
&lt;p&gt;用对象作为 style 方便我们动态设置元素的样式，可以用 props 或者 state 中的数据生成样式对象再传给元素，然后用 setState 就可以修改样式，比如 &lt;code&gt;setState({color: &#39;blue&#39;})&lt;/code&gt; 就可以把元素的颜色改成蓝色。&lt;/p&gt;
&lt;h2 id=&#34;第三方库-prop-types&#34;&gt;第三方库 prop-types&lt;/h2&gt;
&lt;p&gt;给组件的配置参数加上类型验证&lt;/p&gt;
&lt;p&gt;&lt;code&gt;npm install --save prop-types&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import React, { Component } from &#39;react&#39;
import PropTypes from &#39;prop-types&#39;

class Comment extends Component {
  static propTypes = {
    /*传入的 comment 类型必须为 object*/
    comment: PropTypes.object 
  }
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;高阶组件-higher-order-components&#34;&gt;高阶组件 Higher-Order Components&lt;/h2&gt;
&lt;p&gt;高阶组件就是一个函数，传给它一个组件，它返回一个新的组件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;const NewComponent = higherOrderComponent(OldComponent)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其实就是设计模式里面的装饰者模式&lt;/p&gt;
&lt;h2 id=&#34;context&#34;&gt;context&lt;/h2&gt;
&lt;p&gt;普通情况下一个父组件的状态需要通过 props 一层层往下传递到子组件才能使用。如果组件树层次很深的话维护起来简直是灾难。&lt;/p&gt;
&lt;p&gt;而一个组件只要往自己的 context 里放了某个状态，这个组件之下的所有子组件都直接访问这个状态而不需要通过中间组件的传递&lt;/p&gt;
&lt;p&gt;子组件要获取 context 里面的内容必须写 contextTypes 来声明和验证需要获取的状态的类型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Title extends Component {
  static contextTypes = {
    themeColor: PropTypes.string
  }
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;redux&#34;&gt;Redux&lt;/h1&gt;
&lt;p&gt;Redux 是一种架构模式（Flux 架构的一种变种）&lt;/p&gt;
&lt;h2 id=&#34;store&#34;&gt;store&lt;/h2&gt;
&lt;p&gt;用 createStore 产生的新定义的数据类型，通过 store.getState 获取共享状态，通过 store.dispatch 修改共享状态，通过 store.subscribe 监听数据数据状态。&lt;/p&gt;
&lt;h3 id=&#34;共享结构对象&#34;&gt;共享结构对象&lt;/h3&gt;
&lt;p&gt;用拓展运算符共享结构对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let newAppState = { // 新建一个 newAppState
  ...appState, // 复制 appState 里面的内容
  title: { // 用一个新的对象覆盖原来的 title 属性
    ...appState.title, // 复制原来 title 对象里面的内容
    text: &#39;《React.js 小书》&#39; // 覆盖 text 属性
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://static.sitestack.cn/projects/react-naive-book/5f38c25fc06a9681e0d3c3db2a1cab7e.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;reducer-函数&#34;&gt;reducer 函数&lt;/h3&gt;
&lt;p&gt;这个函数规定是一个纯函数，它接受两个参数，一个是 state，一个是 action&lt;/p&gt;
&lt;p&gt;reducer 不允许有副作用，不能在里面操作 DOM，也不能发 Ajax 请求，更不能直接修改 state，它能做的仅仅是初始化和计算新的 state&lt;/p&gt;
&lt;p&gt;如果没有传入 state 或者 state 为 null，它就会返回一个初始化的数据；如果有传入 state，就会根据 action 来“修改“数据（其实规定不能修改 state，而是要通过拓展运算符共享结构对象）。如果它不能识别你的 action，它就不会产生新的数据，而是（在 default 内部）把 state 原封不动地返回。&lt;/p&gt;
&lt;h3 id=&#34;套路&#34;&gt;套路&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// 定一个 reducer
function reducer (state, action) {
  /* 初始化 state 和 switch case */
}
// 生成 store
const store = createStore(reducer)
// 监听数据变化重新渲染页面
store.subscribe(() =&amp;gt; renderApp(store.getState()))
// 首次渲染页面
renderApp(store.getState()) 
// 后面可以随意 dispatch 了，页面自动更新
store.dispatch(...)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;redux-的安装使用&#34;&gt;Redux 的安装使用&lt;/h2&gt;
&lt;p&gt;在工程目录下使用 npm 安装 Redux 和 React-redux 模块：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;npm install redux react-redux --save&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;把 src/ 目录下从本地导入的 connect 改成从第三方 react-redux 模块中导入：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;import { connect } from &#39;./react-redux&#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;改成：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;import { connect } from &#39;react-redux&#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;最后可以删除 src/react-redux.js&lt;/p&gt;
&lt;h1 id=&#34;smart-组件-vs-dumb-组件&#34;&gt;Smart 组件 vs Dumb 组件&lt;/h1&gt;
&lt;p&gt;根据是否需要高度的复用性，把组件划分为 Dumb 和 Smart 组件，约定俗成地把它们分别放到 components 和 containers 目录下&lt;/p&gt;
&lt;p&gt;Dumb 组件只做一件事情：根据 props 进行渲染，而 Smart 负责应用的逻辑、数据，把所有相关的 Dumb、Smart 组件组合起来，通过 props 控制它们。&lt;/p&gt;
- https://yuanyi-au.github.io/posts/reactjsbook/ - 2021 Yuanyi. All rights reserved.</description>
        </item>
    
    
    
        <item>
        <title>开源入门</title>
        <link>https://yuanyi-au.github.io/posts/opensource/</link>
        <pubDate>Fri, 20 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yuanyi-au.github.io/posts/opensource/</guid>
        <description>方圆之所 https://yuanyi-au.github.io/posts/opensource/ -&lt;p&gt;今年夏天有幸参与了 OSPP 2021 这个活动，终于第一次真正接触到向往已久的开源，以这篇文章记录我在这条路上的旅程，希望能越走越远，以后有更多经验分享给大家。&lt;/p&gt;
&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;首先我想说的是，参与开源并不是必须贡献代码，文档写作、视觉设计、组织宣传等也是项目中非常重要的部分。以及在项目社区或者 GitHub Issues 里进行反馈和解答其他人提出的问题，这些都是对开源社区很好的贡献。&lt;/p&gt;
&lt;p&gt;参与开源你需要知道的最重要的事情就是，大胆提问，大胆提交 PR。&lt;/p&gt;
&lt;p&gt;如果项目文档和谷歌搜索都不能解决你的疑问，不要害怕提问，项目维护者能够快速帮助你找到解决问题的方向，而且换个角度想，其他拥有同样疑惑的人也能搜索到你与项目维护者的交流过程，从中受益。也不要担心自己的代码不够好，项目维护者会对你提交的代码进行 review，如果有问题会给出建议，这其实是一个很好的学习机会。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&#34;https://www.igor.pro.br/publica/papers/saner2016.pdf&#34;&gt;这篇文章&lt;/a&gt;里有提到，实际上 28% 的贡献都是随意贡献（比如修正语法排版错误等），修补 bug 的贡献其实也只占到 30%。所以，不要担心，勇敢地在项目中积极交流贡献。&lt;/p&gt;
&lt;p&gt;最后一点，保持礼貌！&lt;/p&gt;
&lt;h1 id=&#34;开源指南放送&#34;&gt;开源指南放送&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://opensource.guide/zh-hans/&#34;&gt;GitHub 开源软件指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://gitee.com/opensource-guide/&#34;&gt;Gitee 开源指北&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://surenpi.com/open-source-best-practice/&#34;&gt;开源最佳实践&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;参与项目的基本流程&#34;&gt;参与项目的基本流程&lt;/h1&gt;
&lt;h2 id=&#34;找到你想要参与的项目&#34;&gt;找到你想要参与的项目&lt;/h2&gt;
&lt;p&gt;如果毫无头绪，我认为最好从自己熟悉的项目开始下手。在之前做项目的过程中肯定用过许多其他工具，在 GitHub 上搜索它们的项目仓库会是一个不错的开始。当然你也可以通过 GitHub 的 &lt;a href=&#34;https://github.com/explore/&#34;&gt;Explore&lt;/a&gt; 板块，或者 &lt;a href=&#34;https://opensourcefriday.com/&#34;&gt;Open Source Friday&lt;/a&gt; 之类的网站来寻找项目。&lt;/p&gt;
&lt;p&gt;我的经验以前端为例，大多数项目都会有 website 仓库，用来维护官网，这是不错的入门方向。据我观察很多项目也会有专门的 console 或者 dashboard 仓库，我看过的几个都是用 React 搭建的。以及也可以尝试自己做一些博客主题开源。&lt;/p&gt;
&lt;p&gt;请注意一个项目的活跃度以及最后活跃时间，项目维护者对 issue 以及 PR 的响应速度如何，以及整个项目的交流氛围，这些都是非常重要的考虑因素。&lt;/p&gt;
&lt;p&gt;较大的开源项目都会有 CONTRIBUTING 文档，用来说明如何为项目做贡献，请仔细阅读。&lt;/p&gt;
&lt;h2 id=&#34;看看-issues-都有些什么&#34;&gt;看看 &lt;code&gt;Issues&lt;/code&gt; 都有些什么&lt;/h2&gt;
&lt;p&gt;很多开源项目在 Issues 板块都会有 &lt;code&gt;good first issue&lt;/code&gt; ，这些 Issue 通常都比较容易上手，有的项目负责人还会给出一些参考指引，是为了让第一次参与该项目的贡献者能够快速熟悉和参与到项目中来。&lt;/p&gt;
&lt;p&gt;如果你想要做出某个实际贡献，先看看 Issues 里有没有类似的问题以及是否被解决，如果没有，你可以先创建一个 Issue 让参与项目的其他人知道你要进行这方面的工作，总之，将问题进度公开，以避免重复劳动。&lt;/p&gt;
&lt;p&gt;创建 Issue 要注意的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供具体的环境配置、操作步骤以及问题的详细情况&lt;/li&gt;
&lt;li&gt;用文字描述，方便其他人检索&lt;/li&gt;
&lt;li&gt;做好标签分类&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;pull-request-基本流程&#34;&gt;Pull Request 基本流程&lt;/h2&gt;
&lt;p&gt;如果你对项目里的一些问题有了解决方案，可以通过 pull request 提交代码。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;fork&lt;/code&gt; 你想要参与的项目，它就会出现在你的仓库列表里&lt;/li&gt;
&lt;li&gt;将你自己仓库里的这个项目 &lt;code&gt;git clone&lt;/code&gt; 到本地&lt;/li&gt;
&lt;li&gt;在本地仓库 &lt;code&gt;git remote add upstream 原仓库地址&lt;/code&gt; ，与原仓库建立连接&lt;/li&gt;
&lt;li&gt;创建一个新的分支，然后开始修改代码&lt;/li&gt;
&lt;li&gt;把改好的代码推送到自己的远程仓库&lt;/li&gt;
&lt;li&gt;在 GitHub 自己的仓库页面上就可以看到 &lt;code&gt;New pull request&lt;/code&gt; 按钮&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;等待-review-结果&#34;&gt;等待 review 结果&lt;/h2&gt;
&lt;p&gt;项目维护者会对你提交的代码进行 review，如果你提交的代码存在问题，对方会做出说明，希望调整代码或者是代码不被接受的原因。如果没有问题，你的代码就将会被 merge 到项目源码里，一次贡献就这样完成了！&lt;/p&gt;
&lt;p&gt;如果你的 PR 暂时没有得到回应，请耐心等待，如果时间超过一周，可以尝试 @ 相关负责人。&lt;/p&gt;
&lt;h1 id=&#34;参与到开源社区中&#34;&gt;参与到开源社区中&lt;/h1&gt;
&lt;p&gt;如果你对某个社区产生兴趣想要参与，在社区的官网或者 GitHub 以及各种社交媒体上都能找到联系方式（比如邮件列表、Slack、SIG 会议），很多开源社区还会专门举办关于如何参与开源贡献的主题会议。&lt;/p&gt;
&lt;p&gt;SIG (Special Interest Group) ：很多社区会定期举办 SIG 会议，不要害怕参与进去。一般来说社区会维护每次 SIG 会议的会议文档以及会议录屏，也可以通过这些方式了解社区或者项目的动态。&lt;/p&gt;
&lt;h1 id=&#34;github-上常见的交流缩写&#34;&gt;GitHub 上常见的交流缩写&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;WIP：Work in progress, do not merge yet.  // 开发中&lt;/li&gt;
&lt;li&gt;LGTM：Looks good to me.  // PR 经过 review 没有问题&lt;/li&gt;
&lt;li&gt;CC：Carbon copy.  // 抄送某人&lt;/li&gt;
&lt;li&gt;RFC：request for comments.  // 我们来讨论下这个问题&lt;/li&gt;
&lt;li&gt;ACK：acknowledgement.&lt;/li&gt;
&lt;li&gt;NACK/NAK：negative acknowledgement.&lt;/li&gt;
&lt;/ul&gt;
- https://yuanyi-au.github.io/posts/opensource/ - 2021 Yuanyi. All rights reserved.</description>
        </item>
    
    
    
        <item>
        <title>使用 Netlify 部署个人网站以及预览 GitHub 上的 PR</title>
        <link>https://yuanyi-au.github.io/posts/netlify/</link>
        <pubDate>Tue, 17 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yuanyi-au.github.io/posts/netlify/</guid>
        <description>方圆之所 https://yuanyi-au.github.io/posts/netlify/ -&lt;p&gt;Netlify 是一个可以用来构建、部署、协作处理 Web 应用程序的云平台。本篇笔记介绍了如何在 GitHub 上添加 Netlify 以便预览提交的 Pull Request 效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../images/netlify-bot.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;也可以参考此笔记将自己的网站部署在 Netlify 上&lt;/p&gt;
&lt;h1 id=&#34;安装准备&#34;&gt;安装准备&lt;/h1&gt;
&lt;p&gt;在 GitHub 上安装 &lt;a href=&#34;https://github.com/apps/netlify&#34;&gt; Netlify &lt;/a&gt;，授权 GitHub 账号&lt;/p&gt;
&lt;p&gt;或者你也可以选择在 &lt;a href=&#34;https://www.netlify.com/&#34;&gt;Netlify 官网&lt;/a&gt; 上进行注册授权&lt;/p&gt;
&lt;h1 id=&#34;new-site-from-git&#34;&gt;New site from Git&lt;/h1&gt;
&lt;p&gt;选择平台 - 选择仓库 - 选择分支 - 基本设置 - deploy site&lt;/p&gt;
&lt;h2 id=&#34;基本设置&#34;&gt;基本设置&lt;/h2&gt;
&lt;p&gt;常见框架对应的 Build command 和 Publish directory 可以看 &lt;a href=&#34;https://docs.netlify.com/configure-builds/common-configurations/&#34;&gt;官网文档&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;环境变量&#34;&gt;环境变量&lt;/h2&gt;
&lt;p&gt;如果第一次 deploy 失败，请查看环境设置，检查版本是否正确&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Site settings &amp;gt; Build &amp;amp; deploy &amp;gt; Environment &amp;gt; Environment variables&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../images/netlify-environment.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;修改域名&#34;&gt;修改域名&lt;/h2&gt;
&lt;p&gt;Netlify 会自动以你的 site name 生成一个域名：&lt;code&gt;[name-of-your-site].netlify.app&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;进入 &lt;code&gt;Domain Setting &amp;gt; Domain management &amp;gt; Custom domains&lt;/code&gt;，可以通过修改 site name 修改域名&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../images/netlify-domain.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;为-pr-生成预览&#34;&gt;为 PR 生成预览&lt;/h1&gt;
&lt;p&gt;进入 &lt;code&gt;Site settings &amp;gt; Build &amp;amp; deploy &amp;gt; Deploy notifications&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../images/netlify-notification.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;选择 ”Add notification“ ，在下拉菜单中选择 “GitHub Pull Request Comment” ，然后选择 “Deploy Preview succeeded” ，保存&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../images/netlify-prcomment.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;现在每个新出现的 PR 都会自动生成一个评论，包含预览链接 &lt;code&gt;deploy-preview-4--yoursitename.netlify.app&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;对开源项目的支持&#34;&gt;对开源项目的支持&lt;/h1&gt;
&lt;p&gt;如果是开源项目，可以阅读 &lt;a href=&#34;https://www.netlify.com/legal/open-source-policy&#34;&gt;Open Source Plan Policy&lt;/a&gt; 相关内容，提交申请表单，就能免费享有 Pro 的功能，团队成员数量无限制&lt;/p&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.netlify.com/site-deploys/deploy-previews/&#34;&gt; Netlify 官网文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://levelup.gitconnected.com/how-to-setup-previews-for-prs-on-your-github-repo-using-netlify-105c80574875&#34;&gt; How to Setup Previews For PRs on Your GitHub Repo Using Netlify &lt;/a&gt;&lt;/p&gt;
- https://yuanyi-au.github.io/posts/netlify/ - 2021 Yuanyi. All rights reserved.</description>
        </item>
    
    
    
        <item>
        <title>package.json 与 package-lock.json</title>
        <link>https://yuanyi-au.github.io/posts/package.json-package-lock.json/</link>
        <pubDate>Tue, 03 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yuanyi-au.github.io/posts/package.json-package-lock.json/</guid>
        <description>方圆之所 https://yuanyi-au.github.io/posts/package.json-package-lock.json/ -&lt;h1 id=&#34;packagejson&#34;&gt;package.json&lt;/h1&gt;
&lt;p&gt;描述项目所需要的各种模块以及配置信息，可以手动编写，也可以在项目根目录用 &lt;code&gt;npm init&lt;/code&gt; 自动生成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;tech-doc-hugo&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;0.0.1&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;Hugo theme for technical documentation.&amp;quot;,
  &amp;quot;main&amp;quot;: &amp;quot;none.js&amp;quot;,
  &amp;quot;scripts&amp;quot;: {
    &amp;quot;test&amp;quot;: &amp;quot;echo \&amp;quot;Error: no test specified\&amp;quot; &amp;amp;&amp;amp; exit 1&amp;quot;
  },
  &amp;quot;repository&amp;quot;: {
    &amp;quot;type&amp;quot;: &amp;quot;git&amp;quot;,
    &amp;quot;url&amp;quot;: &amp;quot;git+https://github.com/google/docsy-example.git&amp;quot;
  },
  &amp;quot;author&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;license&amp;quot;: &amp;quot;ISC&amp;quot;,
  &amp;quot;bugs&amp;quot;: {
    &amp;quot;url&amp;quot;: &amp;quot;https://github.com/google/docsy-example/issues&amp;quot;
  },
  &amp;quot;homepage&amp;quot;: &amp;quot;https://github.com/google/docsy-example#readme&amp;quot;,
  &amp;quot;dependencies&amp;quot;: {},
  &amp;quot;devDependencies&amp;quot;: {
    &amp;quot;autoprefixer&amp;quot;: &amp;quot;^9.8.6&amp;quot;,
    &amp;quot;postcss-cli&amp;quot;: &amp;quot;^7.1.2&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;package.json&lt;/code&gt; 文件要求必须包括&lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;version&lt;/code&gt; 属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;author&lt;/code&gt;：作者，是在 &lt;code&gt;npmjs.org&lt;/code&gt; 网站上的有效账户名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;main&lt;/code&gt;：指定加载入口，默认值时模块根目录下的 index.js&lt;/li&gt;
&lt;li&gt;&lt;code&gt;script&lt;/code&gt;：指定命令行缩写所要执行的命令，默认是一个空的 &lt;code&gt;test&lt;/code&gt; 脚本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;repository&lt;/code&gt;：代码库地址，会直接在组件库的 npm 首页生效&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bugs&lt;/code&gt;：开发者联系方式，一般是代码库的 issues 地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dependencies&lt;/code&gt;：指定项目运行所需要的模块&lt;/li&gt;
&lt;li&gt;&lt;code&gt;devDependencies&lt;/code&gt;：指定项目开发所需要的模块&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bin&lt;/code&gt;：指定各个内部命令对应的可执行文件的位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;license&lt;/code&gt;：开源协议，可看&lt;a href=&#34;https://choosealicense.com/&#34;&gt;Choose an open source license&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;config&lt;/code&gt;：用于添加命令行的环境变量&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;依赖模块的版本&#34;&gt;依赖模块的版本&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;指定版本 16.2.3&lt;/li&gt;
&lt;li&gt;波浪号 ~16.2.3：安装 16.2.x 的最新版本&lt;/li&gt;
&lt;li&gt;插入号 ^16.2.3：安装 16.x.x 的最新版本&lt;/li&gt;
&lt;li&gt;latest：安装最新版本&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;package-lockjson&#34;&gt;package-lock.json&lt;/h1&gt;
&lt;p&gt;描述 &lt;code&gt;node_modules&lt;/code&gt; 文件中所有模块的版本信息，模块来源及依赖的小版本信息，将整个依赖树锁死&lt;/p&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.npmjs.com/cli/v7/configuring-npm/package-json&#34;&gt;npm 官网 package.json 文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.npmjs.com/cli/v7/configuring-npm/package-lock-json&#34;&gt;npm 官网 package-lock.json 文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://javascript.ruanyifeng.com/nodejs/packagejson.html&#34;&gt;package.json文件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6844904006746112007&#34;&gt;package.json 详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/2e459040a29f&#34;&gt;package-lock.json&lt;/a&gt;&lt;/p&gt;
- https://yuanyi-au.github.io/posts/package.json-package-lock.json/ - 2021 Yuanyi. All rights reserved.</description>
        </item>
    
    
    
        <item>
        <title>git 笔记 (2)</title>
        <link>https://yuanyi-au.github.io/posts/git-2/</link>
        <pubDate>Mon, 26 Jul 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yuanyi-au.github.io/posts/git-2/</guid>
        <description>方圆之所 https://yuanyi-au.github.io/posts/git-2/ -&lt;h1 id=&#34;git-rebase&#34;&gt;git rebase&lt;/h1&gt;
&lt;h2 id=&#34;合并不同分支的提交&#34;&gt;合并不同分支的提交&lt;/h2&gt;
&lt;p&gt;将 b 分支上的提交合并到 a 分支上成为一条直线&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout b
git rebase a
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;与-merge-的区别&#34;&gt;与 merge 的区别&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;永远不要在公共项目里使用 rebase&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;merge 采用的是三方合并的原则，没有公共提交节点就无法进行合并&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;git rebase:
&lt;img src=&#34;../images/git-rebase.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;git merge:
&lt;img src=&#34;../images/git-merge.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;rebase 和 merge 的另一个区别是 rebase 的冲突是一个一个解决，先解决第一个，然后用命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add -u
git rebase --continue
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;继续后才会出现第二个冲突，直到所有冲突解决完，而 merge 是所有的冲突都会显示出来。另外如果 rebase 过程中，你想中途退出，恢复 rebase   前的代码则可以用命令&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git rebase --abort&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;合并本地的多次提交&#34;&gt;合并本地的多次提交&lt;/h2&gt;
&lt;p&gt;合并最新的三次提交&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git rebase -i HEAD~3&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;git reabse -i 合并 commit 之后会出现一个匿名的分支，并不是在原来的分支上把 commit 给合并，而是从合并的 start point 开始新生成一个匿名分支然后把原来分支那几个 commit 作为一个 commit 放到新分支上&lt;/p&gt;
&lt;h1 id=&#34;cherry-pick&#34;&gt;cherry-pick&lt;/h1&gt;
&lt;p&gt;将其他分支上的提交应用于 a 分支&lt;/p&gt;
&lt;p&gt;在开源项目里很有用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout a
git cherry-pick &amp;lt;CommitID&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;与-rebase-的区别&#34;&gt;与 rebase 的区别&lt;/h2&gt;
&lt;p&gt;rebase 相当于剪切粘贴， cherry-pick 相当于复制粘贴&lt;/p&gt;
&lt;h1 id=&#34;git-reset-与-git-revert&#34;&gt;git reset 与 git revert&lt;/h1&gt;
&lt;h2 id=&#34;git-reset&#34;&gt;git reset&lt;/h2&gt;
&lt;p&gt;回退到指定的提交版本&lt;/p&gt;
&lt;h2 id=&#34;git-revert&#34;&gt;git revert&lt;/h2&gt;
&lt;p&gt;用一个新的提交来消除之前的提交，原来的 commit 内容依旧会保存在提交历史中&lt;/p&gt;
&lt;h2 id=&#34;两者的区别&#34;&gt;两者的区别&lt;/h2&gt;
&lt;p&gt;reset 是在正常的提交历史中,删除了指定的 commit ，HEAD 向后移动，而 revert 是在正常的提交历史中再 commit 一次，只不过是反向提交可以抵消之前的提交，它的HEAD 是一直向前的&lt;/p&gt;
&lt;h1 id=&#34;git-pull-和-git-fetch-的区别&#34;&gt;git pull 和 git fetch 的区别&lt;/h1&gt;
&lt;p&gt;打开本地 &lt;code&gt;.git/refs&lt;/code&gt; 文件夹我们可以看到代表本地分支的 &lt;code&gt;head&lt;/code&gt; 文件夹和代表正在跟踪的远程分支的 &lt;code&gt;remotes&lt;/code&gt; 文件夹&lt;/p&gt;
&lt;p&gt;使用 git pull 会将两个文件夹里的 commit ID 都更新至远程库的最新 commit ID&lt;/p&gt;
&lt;p&gt;使用 git fetch 只会将 &lt;code&gt;remotes&lt;/code&gt; 文件夹中的 commit ID 更新至远程库的最新 commit ID&lt;/p&gt;
&lt;h1 id=&#34;git-blame&#34;&gt;git blame&lt;/h1&gt;
&lt;p&gt;可以查看某个文件里每一行代码的最后修改提交记录&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git blame &amp;lt;filename&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;sign-off&#34;&gt;sign-off&lt;/h1&gt;
&lt;p&gt;在做开源项目时遇到要求 sign-off，用于证明提交作者&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git commit -s -m &amp;quot;&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;ssh-与-https-克隆代码的区别&#34;&gt;SSH 与 HTTPS 克隆代码的区别&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;HTTPS 使用 443 端口，可以随意克隆 GitHub 上的项目，但进行其他 git 操作时需要验证用户名和密码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SSH 使用 22 端口，操作者必须是项目拥有者，先添加 SSH key 然后才能克隆 GitHub 上的项目&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/hudashi/article/details/7664631?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.control&amp;amp;spm=1001.2101.3001.4242&#34;&gt;git rebase简介(基本篇)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/6960811ac89c&#34;&gt;你真的懂git rebase吗？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qq_43425487/article/details/105620270&#34;&gt;Git应用详解第九讲：Git cherry-pick与Git rebase&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/xybelieve1990/article/details/62885292?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&#34;&gt;Git版本恢复命令reset和revert&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_41975655/article/details/82887273&#34;&gt;详解git pull和git fetch的区别&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/a19881029/article/details/42245955&#34;&gt;git fetch和git pull之间的区别&lt;/a&gt;&lt;/p&gt;
- https://yuanyi-au.github.io/posts/git-2/ - 2021 Yuanyi. All rights reserved.</description>
        </item>
    
    
    
        <item>
        <title>git 笔记 (1)</title>
        <link>https://yuanyi-au.github.io/posts/git-1/</link>
        <pubDate>Sat, 24 Jul 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yuanyi-au.github.io/posts/git-1/</guid>
        <description>方圆之所 https://yuanyi-au.github.io/posts/git-1/ -&lt;p&gt;本篇笔记内容包括常用命令以及 commit message 规范&lt;/p&gt;
&lt;h1 id=&#34;常用命令&#34;&gt;常用命令&lt;/h1&gt;
&lt;h2 id=&#34;名词&#34;&gt;名词&lt;/h2&gt;
&lt;p&gt;workplace 工作区&lt;/p&gt;
&lt;p&gt;stage 暂存区&lt;/p&gt;
&lt;p&gt;repository 本地仓库&lt;/p&gt;
&lt;p&gt;remote 远程仓库&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;新建仓库&#34;&gt;新建仓库&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git init&lt;/code&gt; 在当前目录新建一个本地仓库&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git clone&lt;/code&gt; 将一个远程仓库的内容下载到本地&lt;/p&gt;
&lt;h2 id=&#34;文件的增加删除提交&#34;&gt;文件的增加、删除、提交&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git add [filename]&lt;/code&gt; 将文件从工作区添加到暂存区&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git rm [filename]&lt;/code&gt; 删除工作区文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git rm --cached [filename]&lt;/code&gt; 停止追踪指定文件，但该文件会保留在工作区&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git mv [originalname] [newname]&lt;/code&gt; 文件重命名，并将该文件放入暂存区&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git commit - &amp;quot;message&amp;quot;&lt;/code&gt; 将暂存区文件提交到本地仓库&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git commit -amend -m &amp;quot;message&amp;quot;&lt;/code&gt; 用一次新的 commit 代替上次 commit，可以用来改写 commit message&lt;/p&gt;
&lt;h2 id=&#34;分支管理&#34;&gt;分支管理&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git branch&lt;/code&gt; 查看所有本地分支&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git branch -a&lt;/code&gt; 查看所有本地分支与远程分支&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git branch [branch]&lt;/code&gt; 新建一个分支，但依然停留在当前分支&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git checkout -b [branch]&lt;/code&gt; 新建一个分支并切换到该分支&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git checkout [branch]&lt;/code&gt; 切换到指定分支，并更新工作区&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git merge [branch]&lt;/code&gt; 将指定分支合并到当前分支&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git branch -d [branch]&lt;/code&gt; 删除本地分支&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git push origin --delete [branch]&lt;/code&gt; 删除远程分支&lt;/p&gt;
&lt;h2 id=&#34;远程仓库&#34;&gt;远程仓库&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git remote -v&lt;/code&gt; 查看所有远程仓库&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git remote add [name] [url]&lt;/code&gt; 添加远程仓库&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git remote remove [name]&lt;/code&gt; 删除远程仓库&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git fetch [remote]&lt;/code&gt; 下载远程仓库的所有变动&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git pull [remote] [branch]&lt;/code&gt; 下载远程仓库的变动并与本地仓库合并&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git push [remote] [branch]&lt;/code&gt; 将本地分支推送到远程分支&lt;/p&gt;
&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git config --list&lt;/code&gt; 显示当前配置&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git config -e&lt;/code&gt; 编辑配置文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git status&lt;/code&gt; 显示所有变更文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git log&lt;/code&gt; 显示当前分支的版本历史&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git reset --soft [commit_id]&lt;/code&gt; 回退到某一个 commit 版本，工作区和暂存区不变&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git reset --hard [commit_id]&lt;/code&gt; 回退到某一个 commit 版本，工作区和暂存区也随之更改&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git diff&lt;/code&gt; 显示暂存区与工作区的差异&lt;/p&gt;
&lt;h1 id=&#34;commit-message-规范&#34;&gt;commit message 规范&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://d33wubrfki0l68.cloudfront.net/eb16595d0c6862c0c013a36c339317a4d82bdce7/9195b/images/posts/2019-11-01-understanding-semantic-commit-messages-using-git-and-angular/conventions-diagram.png&#34; alt=&#34;不同的 commit message 规范&#34;&gt;&lt;/p&gt;
&lt;p&gt;通常我们都用 Angular 的规范，具体可以参见 &lt;a href=&#34;https://www.conventionalcommits.org/en/v1.0.0/&#34;&gt;Conventional Commits&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;组成&#34;&gt;组成&lt;/h2&gt;
&lt;p&gt;commit message 包括三部分：header，body 和 footer&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;type&amp;gt;[optional scope]: &amp;lt;description&amp;gt;

[optional body]

[optional footer(s)]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;header&#34;&gt;Header&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;type：用于说明 commit 的类别
&lt;ul&gt;
&lt;li&gt;feat：增加新功能&lt;/li&gt;
&lt;li&gt;fix：修 bug&lt;/li&gt;
&lt;li&gt;docs：文档变动&lt;/li&gt;
&lt;li&gt;style：格式变动，不改变代码逻辑&lt;/li&gt;
&lt;li&gt;refactor：重构（既非feat又非fix的影响代码运行的改动）&lt;/li&gt;
&lt;li&gt;test：增加测试&lt;/li&gt;
&lt;li&gt;chore(or build)：构建过程或辅助工具变动&lt;/li&gt;
&lt;li&gt;ci：与持续集成相关的变动&lt;/li&gt;
&lt;li&gt;perf：改善性能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;scope：用于说明 commit 影响的范围，例如数据层、控制层、视图层等&lt;/li&gt;
&lt;li&gt;subject：用于描述 commit 目的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;body&#34;&gt;Body&lt;/h3&gt;
&lt;p&gt;对 commit 的详细描述，可以分成多行&lt;/p&gt;
&lt;h3 id=&#34;footer&#34;&gt;Footer&lt;/h3&gt;
&lt;p&gt;只用于两种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当前代码与上一版本代码不兼容，则 footer 以 BREAKING CHANGE 开头，接着描述变动的内容、理由及迁移方法&lt;/li&gt;
&lt;li&gt;针对某个 Issue，可以在 footer 部分关闭这个 Issue &lt;code&gt;Close #65 #77&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;revert&#34;&gt;Revert&lt;/h3&gt;
&lt;p&gt;如果当前 commit 是用来撤销之前的 commit，则必须以 &lt;code&gt;revert:&lt;/code&gt; 开头，后面跟着被撤销的 commit 的 header&lt;/p&gt;
&lt;p&gt;body 部分则必须写成:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;This reverts commit 667ecc1654a317a13331b17617d973392f415f02.
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;规则&#34;&gt;规则&lt;/h2&gt;
&lt;p&gt;优秀的 commit massage 应该遵循以下七条规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;subject 和 body 之间空一行&lt;/li&gt;
&lt;li&gt;subject字数限制在50字符以内&lt;/li&gt;
&lt;li&gt;行首字母大写&lt;/li&gt;
&lt;li&gt;subject 不要以句号结尾&lt;/li&gt;
&lt;li&gt;subject 使用祈使句&lt;/li&gt;
&lt;li&gt;body 不超过72个字符&lt;/li&gt;
&lt;li&gt;用 body 部分解释此次 commit 的改动及其原因&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;feat(lang): add polish language
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;refactor!: drop support for Node 6 //使用感叹号代表 breaking change
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;fix: correct minor typos in code

see the issue for details

on typos fixed.

Reviewed-by: Z
Refs #133
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.conventionalcommits.org/en/v1.0.0/&#34;&gt;Conventional Commits 1.0.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://chris.beams.io/posts/git-commit/&#34;&gt;How to Write a Git Commit Message&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://nitayneeman.com/posts/understanding-semantic-commit-messages-using-git-and-angular/&#34;&gt;Understanding Semantic Commit Messages Using Git and Angular&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html&#34;&gt;常用 Git 命令清单&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html&#34;&gt;Commit message 和 Change log 编写指南&lt;/a&gt;&lt;/p&gt;
- https://yuanyi-au.github.io/posts/git-1/ - 2021 Yuanyi. All rights reserved.</description>
        </item>
    
    
    
    
  </channel>
</rss> 